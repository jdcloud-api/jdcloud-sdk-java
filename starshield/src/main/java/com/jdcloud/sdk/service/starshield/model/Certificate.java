/*
 * Copyright 2018 JDCLOUD.COM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http:#www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * 
 *
 * 
 * Contact: 
 *
 * NOTE: This class is auto generated by the jdcloud code generator program.
 */

package com.jdcloud.sdk.service.starshield.model;

import java.util.List;
import java.util.ArrayList;

/**
 * certificate
 */
public class Certificate  implements java.io.Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 在请求中使用证书的顺序/优先级。

     */
    private Number priority;

    /**
     * 来自授权机构的证书过期时间
     */
    private String expires_on;

    /**
     * hosts
     */
    private List<String> hosts;

    /**
     * 域标识符标签
     */
    private String zone_id;

    /**
     * 域的自定义SSL的状态
     */
    private String status;

    /**
     * geo_restrictions
     */
    private Geo_restrictions geo_restrictions;

    /**
     * 上次修改证书的时间
     */
    private String modified_on;

    /**
     * 用于证书的哈希类型
     */
    private String signature;

    /**
     * 颁发证书的证书颁发机构
     */
    private String issuer;

    /**
     * 自定义证书标识符标签
     */
    private String id;

    /**
     * 证书上载到星盾的时间
     */
    private String uploaded_on;

    /**
     * SSL泛捆绑在各处有着最高的概率被验证，甚至能被使用过时的或不寻常的信任存储的客户端验证。
最佳捆绑使用最短的认证链和最新的中间证书。
而强制捆绑会验证证书链，但不以其他方式修改证书链。

     */
    private String bundle_method;


    /**
     * get 在请求中使用证书的顺序/优先级。

     *
     * @return
     */
    public Number getPriority() {
        return priority;
    }

    /**
     * set 在请求中使用证书的顺序/优先级。

     *
     * @param priority
     */
    public void setPriority(Number priority) {
        this.priority = priority;
    }

    /**
     * get 来自授权机构的证书过期时间
     *
     * @return
     */
    public String getExpires_on() {
        return expires_on;
    }

    /**
     * set 来自授权机构的证书过期时间
     *
     * @param expires_on
     */
    public void setExpires_on(String expires_on) {
        this.expires_on = expires_on;
    }

    /**
     * get hosts
     *
     * @return
     */
    public List<String> getHosts() {
        return hosts;
    }

    /**
     * set hosts
     *
     * @param hosts
     */
    public void setHosts(List<String> hosts) {
        this.hosts = hosts;
    }

    /**
     * get 域标识符标签
     *
     * @return
     */
    public String getZone_id() {
        return zone_id;
    }

    /**
     * set 域标识符标签
     *
     * @param zone_id
     */
    public void setZone_id(String zone_id) {
        this.zone_id = zone_id;
    }

    /**
     * get 域的自定义SSL的状态
     *
     * @return
     */
    public String getStatus() {
        return status;
    }

    /**
     * set 域的自定义SSL的状态
     *
     * @param status
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * get geo_restrictions
     *
     * @return
     */
    public Geo_restrictions getGeo_restrictions() {
        return geo_restrictions;
    }

    /**
     * set geo_restrictions
     *
     * @param geo_restrictions
     */
    public void setGeo_restrictions(Geo_restrictions geo_restrictions) {
        this.geo_restrictions = geo_restrictions;
    }

    /**
     * get 上次修改证书的时间
     *
     * @return
     */
    public String getModified_on() {
        return modified_on;
    }

    /**
     * set 上次修改证书的时间
     *
     * @param modified_on
     */
    public void setModified_on(String modified_on) {
        this.modified_on = modified_on;
    }

    /**
     * get 用于证书的哈希类型
     *
     * @return
     */
    public String getSignature() {
        return signature;
    }

    /**
     * set 用于证书的哈希类型
     *
     * @param signature
     */
    public void setSignature(String signature) {
        this.signature = signature;
    }

    /**
     * get 颁发证书的证书颁发机构
     *
     * @return
     */
    public String getIssuer() {
        return issuer;
    }

    /**
     * set 颁发证书的证书颁发机构
     *
     * @param issuer
     */
    public void setIssuer(String issuer) {
        this.issuer = issuer;
    }

    /**
     * get 自定义证书标识符标签
     *
     * @return
     */
    public String getId() {
        return id;
    }

    /**
     * set 自定义证书标识符标签
     *
     * @param id
     */
    public void setId(String id) {
        this.id = id;
    }

    /**
     * get 证书上载到星盾的时间
     *
     * @return
     */
    public String getUploaded_on() {
        return uploaded_on;
    }

    /**
     * set 证书上载到星盾的时间
     *
     * @param uploaded_on
     */
    public void setUploaded_on(String uploaded_on) {
        this.uploaded_on = uploaded_on;
    }

    /**
     * get SSL泛捆绑在各处有着最高的概率被验证，甚至能被使用过时的或不寻常的信任存储的客户端验证。
最佳捆绑使用最短的认证链和最新的中间证书。
而强制捆绑会验证证书链，但不以其他方式修改证书链。

     *
     * @return
     */
    public String getBundle_method() {
        return bundle_method;
    }

    /**
     * set SSL泛捆绑在各处有着最高的概率被验证，甚至能被使用过时的或不寻常的信任存储的客户端验证。
最佳捆绑使用最短的认证链和最新的中间证书。
而强制捆绑会验证证书链，但不以其他方式修改证书链。

     *
     * @param bundle_method
     */
    public void setBundle_method(String bundle_method) {
        this.bundle_method = bundle_method;
    }


    /**
     * set 在请求中使用证书的顺序/优先级。

     *
     * @param priority
     */
    public Certificate priority(Number priority) {
        this.priority = priority;
        return this;
    }

    /**
     * set 来自授权机构的证书过期时间
     *
     * @param expires_on
     */
    public Certificate expires_on(String expires_on) {
        this.expires_on = expires_on;
        return this;
    }

    /**
     * set hosts
     *
     * @param hosts
     */
    public Certificate hosts(List<String> hosts) {
        this.hosts = hosts;
        return this;
    }

    /**
     * set 域标识符标签
     *
     * @param zone_id
     */
    public Certificate zone_id(String zone_id) {
        this.zone_id = zone_id;
        return this;
    }

    /**
     * set 域的自定义SSL的状态
     *
     * @param status
     */
    public Certificate status(String status) {
        this.status = status;
        return this;
    }

    /**
     * set geo_restrictions
     *
     * @param geo_restrictions
     */
    public Certificate geo_restrictions(Geo_restrictions geo_restrictions) {
        this.geo_restrictions = geo_restrictions;
        return this;
    }

    /**
     * set 上次修改证书的时间
     *
     * @param modified_on
     */
    public Certificate modified_on(String modified_on) {
        this.modified_on = modified_on;
        return this;
    }

    /**
     * set 用于证书的哈希类型
     *
     * @param signature
     */
    public Certificate signature(String signature) {
        this.signature = signature;
        return this;
    }

    /**
     * set 颁发证书的证书颁发机构
     *
     * @param issuer
     */
    public Certificate issuer(String issuer) {
        this.issuer = issuer;
        return this;
    }

    /**
     * set 自定义证书标识符标签
     *
     * @param id
     */
    public Certificate id(String id) {
        this.id = id;
        return this;
    }

    /**
     * set 证书上载到星盾的时间
     *
     * @param uploaded_on
     */
    public Certificate uploaded_on(String uploaded_on) {
        this.uploaded_on = uploaded_on;
        return this;
    }

    /**
     * set SSL泛捆绑在各处有着最高的概率被验证，甚至能被使用过时的或不寻常的信任存储的客户端验证。
最佳捆绑使用最短的认证链和最新的中间证书。
而强制捆绑会验证证书链，但不以其他方式修改证书链。

     *
     * @param bundle_method
     */
    public Certificate bundle_method(String bundle_method) {
        this.bundle_method = bundle_method;
        return this;
    }


    /**
     * add item to hosts
     *
     * @param host
     */
    public void addHost(String host) {
        if (this.hosts == null) {
            this.hosts = new ArrayList<>();
        }
        this.hosts.add(host);
    }

}